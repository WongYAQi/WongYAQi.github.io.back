---
title: 隐式类型转换
date: 2019-07-22 23:02:18
tags: javascript
---

javascript的隐式类型转换规则
<!-- more -->
### 原因
为什么会产生隐式类型转换？
==，+两边的值的类型不同，就会发生隐式类型转换。转换得到的是Primitive类型值。
```javascript
 [] == false  //  true
!![] == true  //  true
!!'' == false  //  true
[1] == '1'  //  true
'' == 0  // true
'' == false  //  true
[1] == true  //  true
null == 0  //  false
null == ''  // false
null == undefined  // true
![] == [] //  true
!{} == {} //  false
```
### 转换规则
转换的几种形式

#### 引用类型
将引用类型转换为基础类型，会使用对象的toString方法和valueOf方法。根据具体情况来判断应该先使用哪一种。

#### +一元运算符
+一元运算符会将变量转换为Number类型,使用toNumber方法

#### !一元运算符
!一元运算符会将变量转换为Blooean类型，只有以下几种转换为true，其余都为false

null,undefined,NaN,’ ‘,0 ,false

#### +加法运算符
+运算符优先将两边的变量转换为String类型，所以’1’ + 1 = ‘11’,而不是2.如果其中有引用类型，就需要将引用类型转换为原值Primitive进行操作，先使用toString能否得到原值，如果不能就进行valueOf，能否得到原值，如果都不能，则不能进行加法运算，会抛出异常

#### ==运算符
==运算符会优先将两边的变量转换为Number类型

```javascript
{} == 0 //false
1.{}.valueOf() === {},返回的仍然是一个引用类型，截下来使用toString(),PS:简写
2.{}.toString()返回的是'[object Object]'，将这个值和0比较，而其中无法转换为Number类型
3.将两者转换为String类型，比较'[object Object]' 和 '0'
```

#### 特殊规则
```javascript
1. null == undefined
2. NaN == NaN //false
3. 除了Date类型，其他的引用类型进行原始值转换，如果没有标记要目标类型，那么Date是转换为Number类型，其他的都是转换为String类型
++[[]][+[]]+[+[]]==10?
网传的一个变态的隐式类型转换题。依次来解析下
1.分两个部分，++[[]][+[]] 和 +[+[]]
2.+[] 得到的是一个Number类型，也就是0
3.[[]] 得到的是一个数组，其中第一个元素是一个[]空数组
4.而[[]][0]得到的就是这个数组的第一个元素，也就是这个空数组
5.++[]会进行Number类型转换，[] => ‘’ => 0 => ++0 => 1
6.[+[]] 会成为[0]，代表第一个元素是0的数组
7.1 + [0] 会转换为String类型，所以最后是’1’+’0’ 得到’10’
```